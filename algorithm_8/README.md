# SVD Refinement — Algorithm 8 (Dynamic) Implementation

## Структура проекта

```
./
├── README.md                           # Описание проекта
├── refineSDV8_original.hpp             # Шаблонная реализация алгоритма 8
├── refineSVD8_dynamic.hpp              # Динамическая реализация без реортогонализации
├── refineSVD8_dynamic_reortogonalized.hpp  # Улучшенная версия с реортогонализацией
└── tests/
    ├── test_alg8.cpp                   # Основной модуль тестирования для алгоритма 8
    ├── test_alg8_special.cpp           # Частный случай тестирования с выводом всех матриц
    ├── alg8_test_results.csv           # [output] Результаты тестов без реортогонализации
    ├── alg8_test_results_reortogonalized.csv # [output] Результаты тестов с реортогонализацией
```


## Почему алгоритм 8 требует реортогонализации

Алгоритм 8 обновляет сингулярные компоненты на каждом шаге с использованием формул:

$$
U^{(k+1)} = U^{(k)} + U^{(k)}(E_1 - E_2) + \sqrt{2} U_2^{(k)} E_4
$$

$$
V^{(k+1)} = V^{(k)} + V^{(k)}(E_1 + E_2)
$$

Эти формулы предполагают, что $U^{(k)}$ и $V^{(k)}$ сохраняют ортогональность. Однако в реальных численных вычислениях это свойство может нарушаться после первых итераций из-за накопления ошибок, и матрицы перестают быть ортогональными. Это искажает поправки $E_1$, $E_2$, особенно те, где присутствует деление на $\sigma_i \pm \sigma_j$, и может привести к большому накоплению ошибки при итерациях алгоритма.

Чтобы избежать расходимости, необходимо выполнять **реортогонализацию** $U$ и $V$ на каждом шаге, например, с помощью QR-разложения. Это возвращает их к ортогональным базисам и стабилизирует итерационный процесс.

Например, в 4-м алгоритме уточнение сингулярных значений происходит только по диагонали матрицы $T_{mn}$:

$$
\Sigma_n(i,i) = \frac{T_{mn}(i,i)}{1 - 0.5 \cdot (R(i,i) + S(i,i))}
$$

где $R = I - U^\top U$ и $S = I - V^\top V$ — меры отклонения от ортогональности. Таким образом, ошибки ортогональности не игнорируются, а прямо входят в знаменатель и компенсируют влияние искажения. Это делает алгоритм устойчивее, чем алгоритм 8.


## Реализация

### `refineSVD8_dynamic.hpp`
- Реализация **алгоритма 8** без реортогонализации.
- Используется смешанная точность (`cast<double>()`) для расчётов, возвращается `Matrix<long double>`.
- Поддерживает произвольные прямоугольные размеры `m × n`, где 
`m ≥ n`.
- Без восстановления ортогональности — при больших итерациях или сильных шумовых искажениях приводит к накапливанию ошибки.

### `refineSVD8_dynamic_reortogonalized.hpp`
- Расширение `refineSVD8_dynamic.hpp` с добавлением **реортогонализации**:
  ```cpp
  HouseholderQR<MatrixXd> qrU(U_new);
  U_new = qrU.householderQ();
  ```
- Гарантирует поддержание ортогональности `U`, `V` после каждого шага уточнения.
- Существенно повышает устойчивость на больших итерациях.

### Сигнатура функции
```cpp
void refineSVD8(const Mat& A, Mat& U, Mat& V, Mat& S);
```
- `A` — матрица, которую уточняем.
- `U`, `V` — начальные (зашумлённые) приближения ортогональных матриц.
- `S` — результат: приближённые сингулярные значения.

---

## Тестирование

### `test_alg8.cpp`
- Массовое тестирование всех комбинаций размеров `m × n`, уровней шума и количества итераций.
- Измеряются:
  - `Rec_l1`, `Rec_l2` — ошибки восстановления `A` в `L1` и `L2` норме;
  - `U_err`, `V_err`, `S_err` — ошибки по `U`, `V`, `S`;
  - `Time_ms` — время уточнения.
- Результаты пишутся в:
  - `alg8_test_results.csv` — без реортогонализации;
  - `alg8_test_results_reortogonalized.csv` — с реортогонализацией.

### `test_alg8_special.cpp`
- Проверка частного случая (например, `5×3`) с выводом всех матриц (`A`, `U`, `S`, `V`) до и после итераций.
- Полезен для визуальной отладки.

---

## Зависимости
- [Eigen 3](https://eigen.tuxfamily.org/) — библиотека линейной алгебры.

**ВАЖНО** -  верно подключить библиотеку Eigen в зависимости от среды выполнения и типа установки. В случае для macOS: `#include <eigen3/Eigen/Dense>`


